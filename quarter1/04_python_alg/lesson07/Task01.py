# 1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив, заданный случайными числами на
# промежутке [-100; 100). Выведите на экран исходный и отсортированный массивы.
# Сортировка должна быть реализована в виде функции. По возможности доработайте алгоритм (сделайте его умнее).
import random as rnd
import time

LIST_LENGTH = 30


# Сортировка пузырьком (обычная)
def sort_bubble_1(lst):
    res_lst = lst.copy()
    i = 0
    mx = len(lst) - 1
    while i < mx:
        for j in range(mx):
            if res_lst[j] < res_lst[j + 1]:
                res_lst[j], res_lst[j + 1] = res_lst[j + 1], res_lst[j]
        i += 1
    return res_lst


# Сортировка пузырьком доработанная (выигрыш примерно вдвое)
# Если нам дан интервал значений одинаковый в плюс и минус, то:
# 1) попробуем сначала собрать в один массив положительные значения исходного списка, во второй массив - отрицательные
# 2) отсортируем каждый в отдельности обычным алгоритмом
# 3) так как нам нужно отсортировать по убыванию, то к отсортированному массиву с положительными значениями приклеим
#    массив с отрицательными значениями
def sort_bubble_2(lst):
    neg_lst = []
    pos_lst = []
    for i in lst:
        if i > 0:
            pos_lst.append(i)
        else:
            neg_lst.append(i)
    res_lst = sort_bubble_1(pos_lst)
    res_lst.extend(sort_bubble_1(neg_lst))
    return res_lst


###################################################################
# Были еще такие мысли:
# 1) Подсчитать количество вхождений каждого уникального значения, отсортировать эти уникальные значение и
# в итоговый массив вывести каждое значение нужное количество раз.
# Это будет давать выигрыш на большых объемах данных
# Но это не совсем сортировка пузырьком, а какое-то читерство
###################################################################
rnd.seed(42)
lst_rand = [rnd.randint(-100, 99) for i in range(LIST_LENGTH)]  # сформируем массив случайных чисел
print(lst_rand)

# Засечем время на обычную сортировку
tm_start = time.perf_counter()
lst_sort = sort_bubble_1(lst_rand)
tm_end = time.perf_counter()

print(lst_sort)
print(f'Время выполнения: {(tm_end - tm_start) * 1000 * 1000} mcs')

# Засечем время на сортировку новым алгоритмом
tm_start = time.perf_counter()
lst_sort1 = sort_bubble_2(lst_rand)
tm_end = time.perf_counter()

print(lst_sort1)
print(f'Время выполнения: {(tm_end - tm_start) * 1000 * 1000} mcs')

###################################################################
# LIST_LENGTH = 10000
# Время выполнения: 11532645.700033754 mcs
# Время выполнения: 5608168.400009163 mcs
###################################################################
# LIST_LENGTH = 3000
# Время выполнения: 1057094.0000470728 mcs
# Время выполнения: 498103.9999984205 mcs
###################################################################
# LIST_LENGTH = 1000
# Время выполнения: 122392.69999554381 mcs
# Время выполнения: 53077.799966558814 mcs
###################################################################
# LIST_LENGTH = 30
# Время выполнения: 90.09998757392168 mcs
# Время выполнения: 50.00003147870302 mcs
###################################################################
