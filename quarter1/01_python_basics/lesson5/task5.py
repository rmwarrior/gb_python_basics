# 5. Подумайте, как можно сделать оптимизацию кода по памяти, по скорости.
# Представлен список чисел. Определить элементы списка, не имеющие повторений.
# Сформировать из этих элементов список с сохранением порядка их следования в исходном списке, например:
# src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
# result = [23, 1, 3, 10, 4, 11]

# Решение: Представляю 5 вариантов, из них мне больше нравится вариант 4.
# Вариант 1 ("в лоб") и вариант 4 (улучшенный "в лоб") вполне неплохи для больших наборов данных (по скорости)
# а если еще и с часто повторяющимися элементами то и по памяти (тогда вспомогательные справочники будут небольшими)
# Варианты 2 и 3 (через обычную проверку количества элементов) не подходят для больших объемов данных, но
# для небольших наборов, вполне неплохо
# Множества нам не подойдут, так как они неупорядочены и нам не удасться "сохраненить порядок их следования"
# Вариант 5 пытается использовать множества, и тут всё как-то не очень, и по памяти - запоминаем,
# и по скорости ни то ни сё
# Других вариантов пока не придумал, так как надо:
# -либо помнить элементы которые уже просмотрел (уникальные и неуникальные, чтобы было с чем сравнивать)
# -либо пробегать по всем элементам (тут тоже возможны варианты: пробегать уже просмотренные или пробегать оставшиеся)
# и при этом не забыть порядок

# и так и так мы где-то теряем, либо в скорости либо в памяти
# Вариант с генератором не привожу, так как это скорее крайний случай - от безысходности (когда объем большой,
# а просмотреть как-то надо)


from time import perf_counter

src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
# src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11, 2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11,
#        5, 6, 8, 12, 0, 1, 44, 44, 3, 2, 10, 7, 4, 11]

# Вариант "в лоб" с дополнительной структурой - справочником result_dic:
# Результат 1: [23, 1, 3, 10, 4, 11], Скорость: 6.3000000000007494e-06
# Если источник слишком большой, будет накладно по памяти
# Если много частоповторяющихся элементов, то и по памяти будет неплохо
start = perf_counter()
result_dic = {}
for item in src:  # Идем по элементам и пытаемся записать количество таких эл-тов в справочник
    if item in result_dic.keys():  # если уже был такой элемент,
        result_dic[item] = 2  # запишем 2 (исключив лишнюю математику, увеличивая кол-во на 1 (result_dic[item] + 1))
    else:  # если элемент встретился впервые, добавим в справочник
        result_dic[item] = 1

result = []
for key, value in result_dic.items():  # пробегаем по справочнику и те эл-ты, которые...
    if value == 1:  # ...встретились однажды...
        result.append(key)  # ...добавляем в итоговый список
finish = perf_counter()
print(f'Результат 1: {result}, Скорость: {finish - start}')

# Вариант 2 через обычную проверку количества элементов:
# Результат 2: [23, 1, 3, 10, 4, 11], Скорость: 5.299999999999749e-06
# получилось чуть быстрее и не так накладно по памяти (но при больших объемах данных count очень не выгодно)
start = perf_counter()
result = []
for item in src:  # Идем по элементам...
    if src.count(item) == 1:  # ...и если количество таких эл-тов в списке = 1...
        result.append(item)  # ...добавляем в итоговый список
finish = perf_counter()
print(f'Результат 2: {result}, Скорость: {finish - start}')

# Вариант 3 через обычную проверку количества элементов:
# Результат 3: [23, 1, 3, 10, 4, 11], Скорость: 4.199999999995874e-06
# получилось чуть быстрее и не так накладно по памяти (но при больших объемах данных count очень не выгодно)
start = perf_counter()
result = [item for item in src if src.count(item) == 1]
finish = perf_counter()
print(f'Результат 3: {result}, Скорость: {finish - start}')

# Вариант 4 через 2 справочника, избавился от второго явного цикла:
# Результат 4: [23, 1, 3, 10, 4, 11], Скорость: 6.500000000006501e-06
# получилось чуть быстрее чем первый вариант
start = perf_counter()
single_set = {}
dup_dic = {}
for item in src:  # Идем по элементам и пытаемся записать количество таких эл-тов в справочник
    if item in dup_dic.keys():  # если уже был такой элемент,
        continue  # проскакиваем
    elif item in single_set.keys():  # если элемент в справочнике встретившихся впервые
        dup_dic[item] = 1
        single_set.pop(item)
    else:  # если элемент встретился впервые, добавим в справочник
        single_set[item] = 1

result = list(single_set.keys())
finish = perf_counter()
print(f'Результат 4: {result}, Скорость: {finish - start}')

# Вариант 5 через 2 множества с дубликатами и уникальными:
# Результат 5: [23, 1, 3, 10, 4, 11], Скорость: 7.5999999999964984e-06
# по памяти, наверно лучше чем 1-й и 4-й, но по скорости хуже
start = perf_counter()
single_set = set()
dup_set = set()
for item in src:  # Идем по элементам и пытаемся записать количество таких эл-тов в множества
    if item in dup_set:  # если уже был такой элемент,
        continue  # проскакиваем
    elif item in single_set:  # если элемент в множестве встретившихся впервые
        dup_set.add(item)
        single_set.discard(item)
    else:  # если элемент встретился впервые, добавим в множество
        single_set.add(item)

result = []
# сформируем список уникальных, восстановив порядок встречи
for item in src:  # Идем по элементам исходного списка
    if len(single_set) == 0:  # если множество уникальных опустело выходим
        break
    elif item in single_set:  # если элемент в множестве уникальных...
        result.append(item)  # ...добавим в результат...
        single_set.discard(item)  # ...удалим из множества уникальных

finish = perf_counter()
print(f'Результат 5: {result}, Скорость: {finish - start}')
